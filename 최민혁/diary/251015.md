### 오늘 배운 내용 중 가장 기억에 남는 것

Logging  
어플리케이션의 실행 중 발생하는 이벤트나 상태 정보를 기록하는 것

목적
1. 디버깅 : 개발중 발생하는 문제 해결
2. 모니터링 : 운영 중 시스템 상태 추적
3. 감사 : 보안 및 규정 준수를 위한 기록
4. 성능분석 : 병목 구간 및 성능 문제 파악
5. 비즈니스 분석 : 사용자 행동 패턴 분석

레벨 설정 원칙
- 개발 환경: DEBUG 또는 TRACE  
- 테스트 환경: DEBUG  
- 운영 환경: INFO 또는 WARN  

사용예시
```angular2html
@Slf4j // 롬복 -> 자동으로 looger 필드 생성
public class ExampleService {

    public void process() {
        log.trace("trace 레벨 - 디버깅보다 더 자세한 정보");
        log.debug("debug 레벨 - 디버깅 정보");
        log.info("info 레벨 - 일반 상태");
        log.warn("warn 레벨 - 경고!");
        log.error("error 레벨 - 예외 발생!");
    }
}
```

설정방법
```angular2html
//properties file
# application.properties
logging.level.root=INFO
logging.level.com.myapp=DEBUG
```




MVC model 1
서버에 들어오는 문이 많음..  
비교적 개발이 쉬움  
보안에 취약해질 수 있음

MVC model 2  
서버에 들어오는 문을 하나만 만들어 놓음  
이 문을 Front Controller 라고 부름  
pring MVC는 model2방식을 이용하고 있다.

서블릿  
-> Java 코드안에 HTML을 쓰는 구조    
print문에 문자열로 HTML을 작성하는 방법.

JSP  
-> HTML 안에 자바 코드를 쓰는 구조  
body 에서 <%   Java code %> 형태로 존재    
코드의 노출로 인해 보안에 취약하고 유지보수에도 불리하기 때문에
이제는 권장하지 않는 형태임

동작방식 : HTML +Java -> 서블릿으로 변환



RestController vs Controller  
@RestController  
데이터(JSON/XML)를 반환 (API 용도)
== @Controller class / @ResponseBody @GetMapping("/") 


@Controller  
뷰(View)를 반환 (HTML, JSP, Thymeleaf 등)

@GetMapping  
return 값의 이름과 같은 템플릿을 찾아줌

tomcat  
->Java 웹 애플리케이션을 실행해주는 대표적인 **WAS (Web Application Server)**야.

WAS(Web Application Server)  
클라이언트(브라우저)의 요청을 받아서,
자바 기반의 웹 애플리케이션을 실행하고
동적인 응답(HTML, JSON 등)을 만들어 돌려주는 서버!

Handler Mapping  
-> Controller가 가지고 있는 Mapping 어노테이션 (정확히는 RequestMapping) 을 통해 Value를 가져온다.
이때 Value는 Controll Class에 있는 Mapping에 설정된  URL주소. (/hi) 같은 값  
@GetMapping를 여러개 가지고 있다면 Handler Mapping은
여러개의 정보를 가질 수 있다.

Thymeleaf란?  
HTML 안에 동적으로 데이터를 넣을 수 있게 해주는 템플릿 엔진  


>Spring MVC 아키텍처 요청처리 흐름
> 1. D.S → HandlerMapping      // 요청 URL에 맞는 컨트롤러 찾기
> 2. HandlerMapping → D.S      // 핸들러(컨트롤러) 정보 전달
> 3. D.S → HandlerAdapter      // 컨트롤러 실행
> 4. HandlerAdapter → D.S      // View 이름 반환
> 5. D.S → ViewResolver        // View 이름으로 View 객체 찾기
> 6. ViewResolver → D.S        // View 객체 반환
> 7. D.S → View                // View 렌더링 요청 (Model 포함)
> 8. View → 클라이언트         // 최종 응답(HTML) 전달Handler를 통해



Forwarding  vs Redirect  

Forward(포워딩)  
하나의 요청(Request) 안에서
컨트롤러(또는 서블릿)가 다른 리소스(페이지, 컨트롤러, JSP 등)로 요청을 넘기는 것


Redirect(리다이렉트)

사용자의 요청을 강제로 다른 URL로 이동시키는 것  
이때 클라이언트(브라우저)가 새 URL로 다시 요청을 보냄

```
@GetMapping("/login-success")
public String redirectAfterLogin() {
return "redirect:/home";
}
```
리다이렉트 흐름
>1. 클라이언트가 /login-success로 요청 
>2. 컨트롤러가 "redirect:/home"을 반환
>3. 서버가 HTTP 302 응답과 Location: /home 헤더를 보냄
>4. 브라우저가 자동으로 **새로운 요청 → /home**으로 다시 보냄
>5. /home을 처리하는 컨트롤러가 home 템플릿을 반환
>6. 서버가 home.html을 렌더링해서 브라우저로 응답


### 오늘 배운 내용 중 어려웠던 것
로깅파트에 집중을 잘 못해서 아직 감을 못잡았음.



### 오늘 강의시간, 회고시간에 대한 느낀점
어제 mvc의 전체적인 구조를 예습하고 오늘 흐름을 배웠는데,
재밌었음.. 점점 어려워지는 것 같아 긴장됨..