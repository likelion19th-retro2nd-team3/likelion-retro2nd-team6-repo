
### 오늘 배운 내용 중 가장 기억에 남는 것
#### Scope
1. Page Scope  
- 설명: JSP 페이지 내에서만 유효한 범위.  
- 생명주기: 하나의 JSP 페이지가 실행되는 동안만 사용됨.  
- 사용 예시:   
 ``<jsp:useBean scope="page" />``  
- 특징:  
  - 같은 페이지 안에서는 공유 가능.  
  -  다른 페이지로 넘어가면 사용 불가능.

2. Request Scope  
- 설명: 하나의 HTTP 요청(request)이 처리되는 동안만 유지됨.
- 생명주기: 요청이 시작되어 서버가 응답을 보낼 때까지.
- 사용 예시:  
```<jsp:useBean scope="request" />```
- 특징:
  -  서블릿 → JSP로 포워딩 시 공유 가능 (requestDispatcher.forward()).
  -   새로운 요청이 들어오면 이전 request 범위는 사라짐.
  -  사용자가 브라우저에서 서버로 하나의 요청을 보낼 때,
     서버는 그에 대해 하나의 HttpServletRequest 객체와 
  하나의 HttpServletResponse 객체를 생성.



    [ 브라우저 ]
    ↓   
    [DispatcherServlet (Spring MVC 기준)]  
    ↓   
    [HandlerMapping → HandlerMethod (Controller)]  
    ↓  
    [ViewResolver → JSP (forward)]

이 과정은 모두 같은 요청 처리 흐름 안에 있기 때문에,
request scope도 계속 유지되고, request 객체도 동일.


3. Session Scope
- 설명 : 한 사용자의 브라우저와 서버 사이의 세션 동안 유지됨.
 -  생명주기: 브라우저를 닫거나, 세션이 만료될 때까지.
  - 사용 예시:  
```<jsp:useBean scope="session" />```
  - 특징:
    - 로그인 정보 저장 등에 사용됨.
    - 사용자마다 개별적으로 유지됨.
    - ex) 홈텍스에 로그인했을때 로그인유지시간 30분 되는 것.
    - 브라우저에 머무는동안 유지되는 스코프.

4. Application Scope  
  - 설명: 웹 애플리케이션(서버)의 시작부터 종료까지 유지되는 범위.
  - 생명주기: 웹 컨테이너(서버)가 시작될 때 생성되어 종료 시 삭제됨.
  - 사용 예시:  
`` `<jsp:useBean scope="application" />``
  - 특징:
  - 모든 사용자에게 공통으로 공유됨.
    - 한 사용자가 값을 변경하면, 다른 사용자에게도 영향을 줄 수 있음.
    - 전역 설정값, 공통 자원 저장 등에 적합.
    - 민감한 사용자 정보 저장에는 부적합.



#### JS, CSS는 어떻게 연동(?)되는가?
Spring Boot 기본구조  
📁 src  
└─ 📁 main  
├─ 📁 java  
│   └─ 📄 Controller.java  
└─ 📁 resources  
    ├─ 📁 templates   ← 👈 여기에 Thymeleaf 파일(.html) 있음  
    └─ 📁 static      ← 👈 여기는 JS, CSS, 이미지 파일 등 (정적 리소스)  

static 폴더의 파일 등은 Spring이 관여하지 않고 tomcat이 관여함.  
템플릿을 return으로 받아오는 것처럼 사용하는 것이아닌 코드 내부의 scropt나 link를 통해 직접요청

    [ 브라우저 ]  
    ↓ 요청  
    [ Controller (Java 코드) ]  
    ↓ model.addAttribute("key", value)  
    [ View (JSP, Thymeleaf 등) ]  
    ↑ ${key} ← 이렇게 view에서 꺼냄  

#### Model은 어떻게 작동?
Model은 Controller에서 View(JSP 등)로 데이터를 전달하는 그릇.  
Spring이 @GetMapping을 통해 Model객체를 자동으로 주입해줌

```angular2html
@GetMapping("/greet")
public String greet(Model model) {
    model.addAttribute("name", "Alice");
    return "greeting"; // → greeting.jsp
}
```
#### redirect를 쓰는 이유
1. redirect란?
- 클라이언트에게 다른 URL로 다시 요청하라고 응답하는 제어방식
- 즉, 총 2번의 요청을 받게 됨
2. redirect의 이점
- 각 요청에 따른 하나의 실행만 하기 때문에 중복실행의 위험도를 낮출 수 있다.
3. redirect의 실례
- 로그인
- 결제 등
4. PRG패턴  
Post-Redirect-Get 패턴  
Post로직을 통해 Redirect로 다음 로직을 호출, 호출된 로직의 리턴값인 view를 얻는 패턴  
ex) 브라우저가 결제 요청을 보낸 후 로직이 실행되는 중에  
    브라우저가 새로고침 되어 또다시 같은 요청을 하게 되었다면  
    중복요청이 되어 원하는 값을 받지 못할 수도 있다.  
   (중복 결제가 될 수도 있음 !! 이를 방지할 수 있는 패턴)  

*****redirect 흐름*****
client -> tomcat : 요청  
tomcat -> D.S : 요청을 자바 객체로 변환 후 전달  
D.S -> Handler Mapping : 요청 전달  
Handler Mapping -> D.S : redirect:/url 형태의 String 반환  
D.s -> tomcat : 302 found location : url 형태의 파일로 응답 전달  
tomcat -> client : http 형식으로 반환 후 응답  
client -> tomcat : location 값을 확인 후 get url 재요청  
-- 이후 forwarding과 같은 흐름 --  
tomcat -> D.S : 파싱 후 자바객체로 변환하여 요청 전달  
D.S -> handler Mapping : 요청 전달  
handler Mapping -> D.S : Mapping을통해 로직 위치만 반환  
D.S -> handler adapter : 로직 실행 요청  
handler adapter -> controller -> service -> DTO -> DB -> 역순..->D.S  
: 로직 실행 후 Model, view template명 반환  
D.S -> view resolver : view template명 전달  
view resolver -> D.S : JSP 같은 view 객체로 반환 
D.S -> view : 전달받은 값, Model 객체를 전달  
view - client : Model 객체를 주입후 렌더링, client에게 전달  



#### @PostMapping 로직은 꼭 redirect를 return해야할까?
실행되는 로직이 중요한 데이터를 저장해야한다면 redirect를 해야함. (PRG패턴)  
예외로 로그인 실패나 검색 등은 데이터를 저장할 필요가 없기 때문에 그럴 필요 없음.  


#### @RequestMapping
page에 @RequestMapping이란 애노테이션을 쓰면 로직에 공통적으로 들어가는 url을 생략할 수 있다.
ex)
```
------@RequestMapping 전---
@GetMapping("/item/form")
Logic
@PostMapping("/item/add")
Logic
@GetMapping("/item/list")
Logic

------@RequestMapping 후---
@RequestMapping("/item")
class
@GetMapping("/form")
Logic
@PostMapping("/add")
Logic
@GetMapping("/list")
Logic
```
단, redirect를 return할 때는 url전체를 적어야함.

#### 유효성 검사
1. 유효성 검사란?
- 입력된 값이 올바른지 검사하는 것
- 문제가 있으면 사용자에게 알려서 다시 입력받게 하는 기능

2. 사용법 
- ( build.gradle에 의존성 부여)
```angular2html
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-validation'
}
```
- ( Controller -@Valid)
```angular2html
public String register(@Valid @ModelAttribute("user") User user, BindingResult bindingResult) {
if (bindingResult.hasErrors()) {
return "registerForm"; //오류가 발생했다면 여기로~~
}
return "Welcome";
}
```
@valid 가 유효성 검사를 위한 애노테이션
BindingResult

- ( View Template)
```angular2html
<form th:action="@{/user/register}" th:object="${user}" method="post">
    이름 : <input type="text" th:field="*{name}"><br>
    <div th:if="${#fields.hasErrors('name')}" th:errors="*{name}"></div>
```

#### Thyme leaf 문법
1. 변수 출력
```angular2html
<p th:text="${user.name}"></p>
```
user의 name필드
2. 조건문
```angular2html
<p th:if="${user.age > 18}">성인입니다.</p>
<p th:unless="${user.active}">비활성 사용자</p>
```
if는 true일 때, unless는 false일 때 보임
3. 반복문
```angular2html
<ul>
  <li th:each="item : ${items}" th:text="${item}"></li>
</ul>
```

4. 속성 값 설정
```angular2html
<input type="text" th:value="${user.name}" /> />
```
5. 폼 처리와 바인딩
```angular2html
<form th:action="@{/user/register}" th:object="${user}" method="post">
  이름: <input type="text" th:field="*{name}" />
</form>
```
``th:object="${user}`` : 바인딩할 객체 지정  
``th:field="*{name}""`` : ${user.name} 과 같은 의미

6. 에러처리
7. URL 경로 표현식
8. 메시지 표현식


### 오늘 배운 내용 중 어려웠던 것

### 오늘 강의시간, 회고시간에 대한 느낀점