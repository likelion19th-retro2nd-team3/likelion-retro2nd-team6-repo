### 필드 -> 객체타입(id)
- Default 가 null 이기 때문
- 자료형 을 쓰게 되면 디폴트가 0이라서 오류가 나지 않고 디폴트값으로 저장하게 됨
- 이때 오류가 나지 않기도하고 update는 insert와 같이 save 로 같은 메서드를 공유하기 때문에
그저 update만 될듯..

### @GeneratedValue(strategy = GenerationType.IDENTITY)
- 필드에 붙임
- Create 시 해당 컬럼에 Auto_increment 해서 생성시켜줌

<수업시 오류가 났던 이유>  
해당 애노테이션을 붙이지 않고 테이블을 생성했기 때문  
-> 컬럼에 Auto_increment가 없이 생성되었고 JPA가 이를 인식하지 못해 id를 제대로 생성하지 못했음




### 영속성 컨텍스트
팩토리를 통해 EntityManager 를 생성  
EntityManager에 저장된 값들은 영속성을 가진다
영속성 컨텍스트 == 1차캐시 -> EntityManager에 저장됨..

### EntityManager
🎩 EntityManager는 “사서(librarian)”  
이 사서는 책을 보관하기도 하고(DB에서)  
이미 빌려간 책을 추적하기도 하고(1차 캐시) -> 영속성 컨텍스트  
빌린 책의 변화도 기억하고(snapshot)  
책을 다시 반납할 타이밍도 알고(flush)  
누가 어떤 책을 읽고 있는지 관리까지 해줘요.
- EntityManager 생성
```angular2html
EntityManagerFactory emf = Persistence.createEntityManagerFactory("lionPU");
EntityManager em = emf.createEntityManager();
```
### 객체 생성 및 persistence
```angular2html
Product snack = new Product("과자", 500); //비영속성
   em.persist(snack);  //영속성
```
snack -> 힙공간에 저장  (JVM)  
em.persist(snack) -> em객체에 snack 저장 -> 영속성으로 변환  
em 객체는 JPA가 추적해주는 객체 (DB와 매핑해줌)  

### find
```angular2html
User user = em.find(User.class, 1L); -> 영속성
em.clear(); -> 반영속성
```
-> em객체 안(1차 캐시) 해당 값을 찾고 있으면 return
-> 없으면 db쿼리 실행 후 em에 저장 후 return
-> 이때 em에는 자바 객체(힙에저장된 객체)를 참조하는 객체와 스냅샷이라는 객체가 동시에 저장됨..
-> user는 값을 힙에 자바 객체를 참조
-> clear 시 em에 있는 모든 값들이 사라짐
-> 다만 자바객체는 살아있음..
-> 영속성에 한 번 있었기 때문에 반영속성이라 부름..


내부구조
```angular2html
[EntityManager em]
└── Persistence Context (1차 캐시)
    ├── Managed Entity (User 객체 등)
    └── Snapshot Map (User 객체의 원본 필드값 복사본들)(jvm이 아니라jpa가 관리)
```

### set
```angular2html
User user = em.find(User.class, 1L); 
user.setName("민혁")
em.geTrancsaction().commit()
```
-> user.name을 바꿨는데 em객체가 어떻게 확인하고 쿼리를 날릴까..
-> set을 통해 자바객체가 바뀐다고 바로 쿼리문을 날리진 않음..
-> 이를 commit 했을 때 쿼리문이 날라가는데 이 떄, em에 저장된 자바객체와 
snapshot(복사된 객체)의 값을 비교 후 변경된 값에 대해 update쿼리 문을 날리게 됨


EntityManager
은.. 맵형식으로 되어 있음.. (<class,pk> / value)
value-> javaObject, snapshot


### junit
- 자바에서 테스트 코드를 자동으로 실행하고 결과를 검증해주는 프레임워크

### 사용방법
`` Main -> folder->class
Test -> folder -> class ``

- 모든 경로를 똑같이 생성후 Test class를 만들면  test를 할 수 있다

### Assertions
Assertions 객체를 통해 테스트 메서드에 값을 넣고 실행 할 수 있다.
```
@Test
    public void add(){
        int result = calculator.add(1,2);
        Assertions.assertEquals(3,result);
    } 
```
Assertions import를 달면 Assertions를 기입하지 않고 메서드만 사용할 수 있다.
```angular2html
import static org.junit.jupiter.api.Assertions.*;

@Test
public void add(){
int result = calculator.add(1,2);
assertEquals(3,result);
}

```

### @Test
Test하는 매서드에 기입

### @Before/AfterEach
각 테스트 메서드에 공통적으로 들어가는 로직을 구현

### @Before/AfterAll
클래스 모든 테스트를 시행하기 전과 후에 단 1번 실행되는 로직