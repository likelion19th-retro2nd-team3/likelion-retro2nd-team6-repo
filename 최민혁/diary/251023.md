### Id는 실무에서도 쓰는가

실무에서도 의미없는 id를 pk로 따로 만들어서 사용.
Id나 email등 다 pk가 될 수 있는 후보키지만.. 이걸 pk로 사용하지 않는 이유는..? 
1. 쿼리문을 날릴 때 무거운 문자열을 사용하는 것보다 Long타입의 데이터로 날리는게 비용적으로 좋다.. 
2. email 같은 건 사용자가 모종의 이유로 바꿀 가능성이 있다. 완전한 불변값가 필요하다
3. 인덱싱과 조인에 유리하다 (숫자타입이라서)

*** 그래서 그냥 id나 email은 그냥 unique로 만들어...

### .addShutdounHook
Runtime.getRuntime().addShutdownHook(new Thread())

JVM이 죽기 직전에 마지막으로 이 쓰레드를 사용하세요~~! 라는 메서드..
이 메서드를 통해 JUtil에서 만들어진 emf를 close한다..
thread를 매개변수로 받기 때문에 람다를 사용하고.. run을 오버라이딩 해서 구현한다..
```angular2html
static{
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if(emfInstance!=null){
                System.out.println("===EntityManagerFactory 종료 ====");
                emfInstance.close();
            }
        }));
```
### Static{}
정적 초기화 블럭이라고 부른다.
자바 클래스가 실행될 때 가장 먼저 실행되는 블럭.
이 때, 위 로직을 넣으면 자바클래스에게
"너 죽기전에 이거 끄고 죽어라.."라고 명령하는 거임







### 스키마

스키마 = 테이블에 대해 Hibernate가 추론하는 모든 구조
 - 테이블 이름
 - 컬럼이름
 - 컬럼 타입
 - 제약 조건
 - 키 정보
 - 인덱스
 - 컬럼 순서
 - 연관관계



### 연관관계 
(fk를 가진 T와 참조 T의 관계)
M -> many   T->to     O -> one
@MTO
@MTM
@OTM
@OTO

### @JoinClumn( name = "table_column"
실제 조인되는 상대 테이블의 값을으로..


### @OneToMany(mappedBy = "school")
   ``private List<Student> students; `` 
실제로 DB에선 School 컬럼에 stuendt에 관한 건 없음.. fk가 없다는 뜻!!
그래서 entity로 가질때는 연관관계 애노테이션에 (mappedBy = "school") 를 붙여야함..
student에 School 객체랑 조인되어 있는 객체이 이름을 적어야함!


### orphanRemoval
orphanRemoval = true
해당 school이 삭제됐을때  해당되는 student row를 삭제..

orphanRemoval = false
해당 school이 삭제됐을 때 해당되는 student의 school_id 컬럼 값이 null

Fetch
1. EAGER -> 객체가 생성될 때 필드의 리스트가 전체적으로 싹 조회됨 (1차캐시로 넘어온다는 뜻)
2. LAZY ->  객체가 생성되고 필드의 리스트에 접근이 될 때 싹 조회됨 
- > 조회는 모든 행을 select으로 조회하게됨.
  > join을 하고 싶을 때는 직접 입력해줘야아함..


