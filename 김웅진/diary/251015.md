### 오늘 배운 내용 중 가장 기억에 남는 것
로깅과 스프링 MVC를 위주로 공부하였다. 앞에서 배운 내용들을 구조적으로 복잡하게 배운 것은 인생 처음이었다.
로깅(Logging)은 애플리케이션이 실행 중에 발생하는 **이벤트나 상태 정보를 기록**하는 행위를 의미하며, 다음과 같은 다양한 상황에서 매우 유용합니다.

로깅 시스템은 단순히 정보를 출력하는 `System.out.println`과 달리, 애플리케이션의 **개발 단계**부터 **운영 상태**에 이르기까지 전반적인 프로세스를 효율적으로 관리할 수 있게 해줍니다.

## 1. 개발 단계에서의 유용성 (디버깅 및 효율성)

개발 초기 단계에서 로깅은 코드를 검증하고 문제를 빠르게 해결하는 데 필수적입니다.

*   **디버깅 (Debugging):** 개발 중에는 로그를 출력하여 **무엇이 잘못되었는지** 확인하고 문제를 디버깅하는 데 사용됩니다.
*   **상세 정보 확인:** 개발 환경에서는 **Debug**나 **Trace**와 같은 상세한 로그 레벨을 설정하여, 코드의 흐름이나 변수 값 등 상세한 정보를 콘솔에 출력할 수 있습니다.
*   **코드 유지보수:** 로깅 프레임워크를 사용하면, `System.out.println`처럼 개발이 끝난 후 해당 코드를 **다 삭제**해야 하는 번거로움이 없습니다. 로깅 코드는 그대로 남겨두고 **설정만 바꿔주면** 운영 환경에서 해당 로그가 동작하지 않도록 할 수 있습니다.

## 2. 운영 단계에서의 유용성 (문제 추적 및 분석)

애플리케이션이 실제 서비스 환경에서 운영될 때, 로깅은 안정성과 성능 유지를 위해 핵심적인 역할을 합니다.

*   **운영 상태 추적 및 분석:** 운영 상태에서는 로그들을 적절히 남김으로써 **실제 어떤 값이 들어왔을 때** 문제가 발생했는지, **어떤 시간에** 어떤 문제가 있었는지 등 사용자의 행동 패턴을 추적해낼 수 있습니다.
*   **보안 및 성능 기록:** 보안에 대한 기록이나 **성능 분석**을 위한 기록을 남기는 데도 유용합니다.
*   **자원 소모 방지:** `System.out.println`은 서버의 콘솔에 출력될 때 많은 자원을 잡아먹으므로 운영에 바람직하지 않지만, 로깅 프레임워크는 이러한 자원 소모 문제를 해결합니다.
*   **비즈니스 분석:** 사용자 행동 패턴 분석, 비즈니스에 대한 분석 등 다양한 데이터를 기록하고 분석할 수 있습니다.

## 3. 고급 기능 및 유연성 확보

로깅 프레임워크(예: SLF4J 및 Logback)가 제공하는 다양한 기능들은 개발 및 운영 유연성을 높여줍니다.

*   **로그 레벨 제어:** 로깅 프레임워크는 메시지에 **Trace, Debug, Info, Warn, Error**와 같은 로그 레벨을 부여합니다. 이를 통해 **어디까지만 출력할지**를 레벨에 따라 결정할 수 있습니다.
    *   예를 들어, 운영할 때는 **Warn** 또는 **Error** 레벨만 출력되도록 레벨을 올리면, 개발 단계에서 사용했던 상세 로그들(Trace, Debug)은 출력되지 않아 불필요한 콘솔 출력을 막고 성능을 유지할 수 있습니다.
    *   또한, 설정 파일(`.properties` 등)을 통해 **패키지별로** 로그 레벨을 다르게 지정하는 것도 가능합니다.
*   **출력 대상 변경:** 로깅 프레임워크를 이용하면 로그를 콘솔뿐만 아니라 **파일**에다 출력한다든지, **데이터베이스**에 출력한다든지, **네트워크를 통해** 출력한다든지 하는 다양한 작업이 가능합니다. 로그 파일을 설정하여 파일의 이름, 경로, 크기, 히스토리 개수 등을 지정할 수도 있습니다.
*   **코드 변경 없는 설정 변경:** 운영 중에 로깅 설정을 변경하더라도 **설정 파일만 수정**하면 되기 때문에, 애플리케이션을 재배포하거나 코드를 수정할 필요가 없습니다.
*   **처리 속도:** 로깅 프레임워크는 비동기 처리로 설정하는 것이 가능하여 동기 처리로 실행되는 `System.out.println`보다 빠릅니다.
### 오늘 배운 내용 중 어려웠던 것
오늘 다룬 내용 중 가장 이해하기 어렵고 집중적인 사고를 요구했던 부분은 프레임워크 내부 동작 원리를 설명하는 심화 주제였습니다.
1. 어노테이션과 리플렉션 (Reflection)의 결합:
   ◦ @Controller나 @Component 같은 어노테이션이 단순히 표식이 아니라, 프레임워크가 리플렉션이라는 기술 (java.lang.reflect 패키지)을 이용해 실행 시점에 클래스의 구조(메서드, 필드, 생성자)를 분석하고 접근하여, 해당 어노테이션이 붙어 있는지 확인하고 그에 맞는 동작(빈 등록, DI 등)을 수행한다는 원리가 복잡하게 느껴졌습니다.
   ◦ 리플렉션 자체가 컴파일 시점이 아닌 실행 중에 작동하여 강력하지만, 성능 저하나 캡슐화 문제 등 단점도 동시에 가진다는 점을 이해하는 데 시간이 필요했습니다.
2. Command Line Runner의 람다 표현식 활용:
   ◦ 스프링 부트가 완전히 실행된 후 특정 코드를 실행하기 위해 Command Line Runner 인터페이스를 사용했는데, 이 인터페이스를 빈으로 직접 등록할 때 람다 표현식으로 처리하는 부분이 어려웠습니다.
   ◦ 단순한 인터페이스 구현 방식을 넘어, 람다식이 내부적으로 커맨드라인 러너를 구현한 객체를 생성하여 리턴하고, 이 리턴된 객체가 IOC 컨테이너에 빈으로 등록된다는 자바의 근본적인 메커니즘을 이해하는 데 집중력이 요구되었습니다.
### 오늘 강의시간, 회고시간에 대한 느낀점
스프링 구조가 저에게는 상당히 이해하는데에 난이도가 있는 내용으로 다가왔습니다. 특히 내부 동작 원리는 난해해서 별도의 시간을 할애하여 독학할 필요성이 대두되었습니다.