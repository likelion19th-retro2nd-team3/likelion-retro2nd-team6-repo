### 오늘 배운 내용 중 가장 기억에 남는 것

오늘은 스프링 환경에서 외부 설정값을 어떻게 코드로 가져와서 사용하는지 깊이 있게 배웠다. 특히 @PropertySource를 통해 외부에 있는 프로퍼티 파일을 불러오고, @Value 어노테이션으로 그 값을 필드에 주입하는 방법을 실습했다.

예시로 @PropertySource로 app.properties 파일을 읽고, @Value로 그 안에 있는 값을 가져와서 사용하는 코드를 작성해보니 환경설정을 코드와 분리해서 관리하는 이점이 명확히 다가왔다. 이 과정을 통해 스프링의 강력한 DI(의존성 주입) 기능이 실제 코드에서 어떻게 동작하는지 더 깊이 이해할 수 있었다.

예시 코드

# app.properties
app.name=My Spring App
app.version=1.0

// AppConfig.java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource("classpath:app.properties") // app.properties 파일을 읽어옴
public class AppConfig {

    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private double appVersion;

    public void printInfo() {
        System.out.println("Application Name: " + appName);
        System.out.println("Application Version: " + appVersion);
    }
}
AppConfig 클래스에서 @PropertySource로 app.properties 파일을 지정하고, @Value("${...}")를 사용해 프로퍼티 파일에 정의된 app.name과 app.version 값을 필드에 주입하는 방식이다. 이렇게 하면 애플리케이션의 핵심 로직과 설정값을 분리해 유지보수성을 높일 수 있다.

### 오늘 배운 내용 중 어려웠던 것

스프링 컨테이너에 빈(Bean)을 등록하고 의존성을 주입하는 과정이 초반에 조금 헷갈렸다. 특히 @Bean, @Component, @Autowired, @ComponentScan 이 네 가지 어노테이션의 역할이 명확히 구분되지 않았다.

@Bean은 @Configuration 클래스 안에서 메서드에 붙여 개발자가 직접 객체를 생성하고 스프링 컨테이너에 등록할 때 사용한다.

@Component는 클래스 자체에 붙여 스프링이 자동으로 빈으로 등록해주도록 한다.

@ComponentScan은 @Component 같은 어노테이션이 붙은 클래스들을 특정 패키지부터 자동으로 스캔해서 빈으로 등록해주는 역할을 한다.

@Autowired는 등록된 빈들 간에 의존성을 자동으로 연결해주는 역할을 한다.

이러한 어노테이션들의 역할과 스프링 컨테이너의 동작 흐름을 다시 한번 정리해 보니 @Autowired가 여러 개의 빈을 주입받을 때 @Qualifier 같은 추가 어노테이션이 필요하다는 점도 함께 이해할 수 있었다.
스프링 컨테이너 동작 흐름 요약
컨테이너 시작: ApplicationContext가 생성되면서 스프링 컨테이너가 가동된다.

컴포넌트 스캔: @ComponentScan으로 지정된 패키지를 스캔해서 @Component 계열(@Service, @Repository 등) 어노테이션이 붙은 클래스들을 찾는다.

빈 등록: @ComponentScan으로 찾은 클래스들과 @Bean 메서드가 반환하는 객체들을 모두 스프링 컨테이너의 '빈'으로 등록한다.

의존성 주입: @Autowired가 붙은 필드, 생성자, 메서드에 필요한 빈을 찾아 연결해준다.

외부 설정 주입: @PropertySource로 불러온 외부 파일의 값을 @Value로 주입한다.

애플리케이션 실행: 모든 준비가 끝나면, 컨테이너에서 필요한 빈을 꺼내 사용하며 애플리케이션이 동작한다.

### 오늘 강의시간, 회고시간에 대한 느낀점

오늘 강의를 통해 스프링의 **핵심 개념인 IoC(제어의 역전)와 DI(의존성 주입)**가 단순히 이론적인 이야기가 아니라 실제 코드로 어떻게 구현되는지 직접 체감할 수 있었다. 특히 @Value와 @PropertySource를 같이 사용하면서 외부 설정값을 주입하는 흐름을 이해하는 데 큰 도움이 되었다. 처음에는 어노테이션들이 너무 많아서 어렵게 느껴졌지만, 하나씩 그 역할을 알아가니 스프링의 구조가 퍼즐처럼 맞춰지는 느낌이다.

앞으로 남은 강의에서도 오늘처럼 하나씩 개념을 연결해가며 스프링을 정복해나가고 싶다. 다음 시간에는 어떤 새로운 개념을 배우게 될지 기대된다.