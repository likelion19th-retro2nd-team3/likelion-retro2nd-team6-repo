### 오늘 배운 내용 중 가장 기억에 남는 것
#### <오늘 배운 회원가입 코드를 바탕으로 작성>
* MVC 분리:
    * Controller는 중간에서 데이터와 화면을 연결
    * Domain(User)은 검증 규칙을 포함한 데이터 그릇
    * View(Thymeleaf)는 모델을 화면에 출력

* 검증 플로우
    * @vaild -> user의 어노테이션 검사 -> 에러는 BindingResult로 전달 -> 
      에러 있으면 같은 뷰를 forward(입력값/오류 그대로) 없으면 다음 단계로 이동
      <br>
      <br>
  
#### Controller에 들어있는 개념 정리
```java
@Controller
@RequestMapping("/user") 
public class UserController {

  @GetMapping("/register")
  public String registerForm(Model model) {
    model.addAttribute("user", new User());
    return "registerForm"; // 뷰의 논리적 이름 - forward 방식
  }

  @PostMapping("/register")
  public String register(
      @Valid @ModelAttribute("user") User user,  //데이터 -> User객체에 바인딩하고 검증 수행
      BindingResult bindingResult    // 검증 결과(에러)를 받음 (항상 @Valid 바로 뒤)
  ) {
    if (bindingResult.hasErrors()) {
      return "registerForm"; //에러면 같은 뷰로 forward(입력값/에러 메시지 그대로 표시)
    }
    return "welcome";  //성공하면 다음 화면(여기서 redirect 방식을 많이 씀)
  }
}
```
* @ModelAttribute("user"): 폼의 루트 객체 이름을 지정(뷰의 th:object="${user}"와 연결)
* @Valid: User에 선언한 검증 어노테이션(@NotEmpty 등)을 실제로 검증!하라는 표시.
* BindingResult: 검증 결과가 담기고, 반드시 @Valid 바로 뒤에 와야 함(순서 틀리면 무시)
<br>
  <br>
#### Domain(User)에 들어있는 개념 정리
```java
@Getter @Setter
@AllArgsConstructor @NoArgsConstructor
public class User {

  @NotEmpty(message = "이름을 입력하세요!")
  private String name;

  @NotEmpty(message = "아이디를 입력하세요!")
  private String username;

  @NotEmpty(message = "이메일을 입력하세요!")
  @Email(message = "이메일 형식에 맞게 입력하세요")
  private String email;

  @NotEmpty(message = "비밀번호를 입력하세요!")
  @Size(min = 4, max = 8, message = "비밀번호는 4~8자 사이만 입력됩니다")
  private String password;

  private boolean admin;
}
```
* @NotEmpty, @Email, @Size : Bean Validation 표준 어노테이션(검증 규칙)
* @NoArgsConstructor : 아무 매개변수 없는 생성자를 자동으로 만들어줌.
                        스프링이 폼 데이터를 객체에 넣을 때 빈 객체를 하나 만들고, 거기서 setter로 값을 채워넣음
* @Getter / @Setter : getter&setter 메서드를 자동으로 만들어줌
<br>
<br>
### 오늘 배운 내용 중 어려웠던 것
#### + forward와 redirect의 차이점
* **forward** 
* 같은 요청안에서 다른 HTML로 /"넘겨주는" 방식 <br>
            요청은 한번만 일어나고, 주소창은 바뀌지 않음<br>
            like 한 공간 안에서 자리만.. 옮기는 느낌?<br>
            서버 내부에서 그대로 다음 화면을 보여줌
<br>
<br>
* **redirect**
* 클라이언트가 새로 요청하게 하는 방식 <br>
            1. 서버가 "다시 이 주소로 요청해줘!" 응답을 보냄<br>
            2. 브라우저가 새로은 GET요청을 보냄<br>
            3. 주소창이 바뀌고 이전 요청 데이터가 사라짐<br>
            --> 폼 검증 성공 후에 새 페이지로 이동<br>
            중복방지


* 구조흐름
```angular2html
Controller
 ┣ 요청 받기 (@GetMapping, @PostMapping)
 ┣ Model에 데이터 담기
 ┗ View 이름 리턴 ("registerForm")
       ↓
ViewResolver → HTML 찾기
       ↓
Thymeleaf → 화면 렌더링
```
1. Controller가 URL/메서드에 맞는 요청을 받음
2. 필요한 데이터를 Model에 담고, 보여줄 화면의 논리적 이름을 반환
3. ViewResolver가 그 이름을 실제 템플릿 경로로 바꿈
   <br>_ViewResolver란? Controller가 반환한 ‘이름’을 진짜 HTML 파일로 찾아주는 번역기_
4. Thymeleaf가 모델 값을 끼워넣어 최종 HTML을 만듦
5. HTML이 브라우저에 응답된다

* 스코프 (page, request, session, application)
* 상태관리 - 쿠키, 세션

### 오늘 강의시간, 회고시간에 대한 느낀점
어제 결석해서 로깅과 Spring MVC의 아키텍처 및 요청 처리 흐름을 제대로 듣지 못했다.
특히 DispatcherServlet, HandlerMapping, ViewResolver 같은 핵심 개념을 놓친 것이 아쉽다.
<br>이번 주 안에 강의 자료를 다시 찾아보며 복습하고,
Spring MVC가 요청을 받고 응답을 만드는 전체 과정을 스스로 정리해볼 계획이다.
<br>MVC의 큰 흐름을 이해하는 것이 앞으로의 공부에 중요한 기반이 될 것 같다.









