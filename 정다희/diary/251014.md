### 오늘 배운 내용 중 가장 기억에 남는 것

오늘은 스프링에서 환경설정 값을 외부에서 주입받는 방법에 대해 배웠다.  
@PropertySource를 사용해서 외부 프로퍼티 파일을 불러오고, @Value 어노테이션을 통해 해당 값을 필드에 주입하는 방법을 실습했다.  
예시로 GameConfig 클래스를 만들어서, game.properties 파일에 저장된 값을 @Value로 불러와서 사용하는 코드를 작성해봤다.  
이 과정을 통해 환경설정과 코드의 분리, 그리고 스프링의 DI(의존성 주입) 기능을 더 깊이 이해할 수 있었다.

#### 예시 코드

아래는 GameConfig, Dice, Player 클래스를 예시로,  
`@PropertySource`와 `@Value` 어노테이션을 사용하는 방법을 보여준다.

**game.properties**
```properties
game.max-player=4
game.dice-face=6
player.default-name=Guest
```

**GameConfig.java**
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource("classpath:game.properties") // game.properties 파일을 읽어옴
public class GameConfig {

    @Value("${game.max-player}")
    private int maxPlayer; // game.properties의 game.max-player 값을 주입

    @Value("${game.dice-face}")
    private int diceFace;

    public int getMaxPlayer() {
        return maxPlayer;
    }

    public int getDiceFace() {
        return diceFace;
    }
}
```

**Dice.java**
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.util.Random;

@Component
public class Dice {
    @Value("${game.dice-face}")
    private int face; // game.properties의 game.dice-face 값을 주입

    private Random random = new Random();

    public int roll() {
        // 1부터 face까지의 랜덤 숫자 반환
        return random.nextInt(face) + 1;
    }
}
```

**Player.java**
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Player {
    @Value("${player.default-name}")
    private String name; // game.properties의 player.default-name 값을 주입

    public String getName() {
        return name;
    }
}
```

위 코드에서 `@PropertySource("classpath:game.properties")`는 해당 설정 파일을 읽어오게 하고,  
`@Value("${...}")`는 properties 파일의 값을 각 필드에 주입한다.  
이렇게 하면 환경 설정을 코드와 분리하여 관리할 수 있다.

***

### 오늘 배운 내용 중 어려웠던 것

@Bean과 @Component의 차이점, 그리고 @ComponentScan의 역할, @Autowired의 동작 방식이 헷갈렸다.  

@Bean은 개발자가 직접 메서드에 붙여서 객체를 생성하고 빈으로 등록하는 것이고,  
@Component는 클래스에 붙여서 자동으로 빈으로 등록되는 점이 다르다.  

@ComponentScan은 지정된 패키지 이하에서 @Component가 붙은 클래스를 자동으로 검색해서 빈으로 등록해주기 때문에  
패키지 구조와 스캔 범위가 중요하다는 것도 새로 알게 되었다.  

또한 @Autowired가 생성자, 필드, setter 등 여러 방식으로 의존성을 주입할 수 있다는 점과,  
주입 대상이 여러 개인 경우 에러가 날 수 있으니 주의해야 한다는 점이 어렵게 느껴졌다.


#### 스프링 동작 흐름 정리

1. 스프링 컨테이너(ApplicationContext)가 생성된다.
2. @ComponentScan이 지정된 패키지에서 @Component, @Service, @Repository, @Controller 등이 붙은 클래스를 자동으로 찾아서 빈으로 등록한다.
3. @Bean이 붙은 메서드가 있으면 해당 메서드의 반환 객체를 빈으로 등록한다.
4. 빈 등록이 끝나면, @Autowired가 붙은 필드/생성자/setter에 의존성 주입이 이루어진다.
5. 외부 설정이 필요한 경우 @PropertySource로 properties 파일을 불러오고, @Value로 값을 주입한다.
6. 최종적으로 필요한 객체를 컨테이너에서 꺼내서 사용한다.

***

### 오늘 강의시간, 회고시간에 대한 느낀점

>오늘 수업을 통해 스프링의 의존성 주입 개념이 실제 코드에서 어떻게 작동하는지 감이 잡혔다.  
@Value와 @PropertySource를 함께 사용하면서 외부 설정값을 주입하는 흐름을 이해할 수 있었다.  
처음에는 어노테이션들이 많아서 헷갈렸지만, 하나씩 연결해보니 스프링의 구조가 점점 명확해지는 느낌이었다.
