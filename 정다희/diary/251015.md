### 오늘 배운 내용 중 가장 기억에 남는 것
#### 로깅(Logging)
로깅(Logging)이란 애플리케이션이 실행되는 동안 발생하는 상태, 흐름, 예외, 시스템 정보 등을 기록(Log)으로 남기는 행위를 말한다.  
Spring Boot는 기본적으로 SLF4J + Logback 조합을 내장하고 있어서 별도의 설정 없이 Logger를 바로 사용할 수 있다.  

Spring Boot의 기본 로깅 구조는  
1. SLF4J: 로깅 인터페이스  
2. Logback: 실제 로그를 출력하는 구현체  

이렇게 구성되어 있다. SLF4J는 통로이고 Logback은 출력기라고 보면 된다.

로깅은 중요도나 심각도에 따라 단계적으로 5단계로 레벨을 구분한다.  
로그의 출력 우선순위는 **TRACE < DEBUG < INFO < WARN < ERROR** 순이다.  
예를들어 INFO로 설정하면 INFO, WARN, ERROR만 출력된다.  

- **TRACE**: 가장 상세한 로그 - 메서드 호출, 변수 값 등 세부 실행 흐름 추적 (거의 사용X)
- **DEBUG**: 디버깅용 - 개발 중 로직 확인, 흐름 점검
- **INFO**: 일반정보 - 서비스 동작, 상태 변화 기록
- **WARN**: 경고 - 문제 가능성이 있는 상황 (정상 동작은 가능)
- **ERROR**: 오류 - 예외, 서비스 중단 등 심각한 문제 발생

개발 환경에서는 보통 DEBUG단계를 사용하여 상세한 실행 흐름을 확인하고,  
테스트 환경에서는 INFO단계를 사용하여 정상 동작 중심으로 로그를 확인한다.  
운영 환경에서는 WARN 또는 ERROR 단계를 사용하여 필수 로그만 남겨 성능 저하를 방지한다.

Spring Boot는 기본적으로 INFO 수준으로 동작한다.

***

### 오늘 배운 내용 중 어려웠던 것
#### Spring MVC 아키텍쳐 요청 처리 흐름
```text
[1] Client
     │
     ▼
[2] DispatcherServlet  ← (Front Controller)
     │
     │  요청 URL 분석 후
     ▼
[3] HandlerMapping
     │
     │  어떤 Controller가 처리할지 결정
     ▼
[4] HandlerAdapter
     │
     │  Controller 실행 준비
     ▼
[5] Controller
     │
     │  비즈니스 로직 호출
     ▼
[6] Service  ───→  Repository  ───→  Database
     │                         ▲
     │                         │
     └────────────── 결과(Model)에 저장 ───────────────┘
     │
     ▼
[7] Controller (view name 반환)
     │
     ▼
[8] ViewResolver
     │
     │  "userList" → "/WEB-INF/views/userList.jsp"
     ▼
[9] View
     │
     │  Model 데이터로 HTML 렌더링
     ▼
[10] DispatcherServlet
     │
     ▼
[11] Client (Response 전송)
```

1. **클라이언트 요청 (Request)**
   - 사용자가 URL을 호출하면 요청이 DispatcherServlet으로 전달됨
   - 이 서블릿은 모든 요청의 Front Controller 역할을 함
     <br><br>
2. **HandlerMapping (핸들러 매핑 탐색)**
   - DispatcherServlet은 요청 URL을 분석해서 어떤 Controller가 처리할지 찾기 위해 HandlerMapping에게 물어봄
   - @RequestMapping, @GetMapping 등의 정보를 보고 매핑된 Controller를 반환.
     <br><br>
3. **HandlerAdapter (핸들러 실행 준비)**
   - HandlerAdapter는 찾은 Controller를 실제로 실행할 수 있도록 도와주는 어댑터 역할
   - 다양한 Controller 형태(@Controller, @RestController 등)를 처리 가능.
     <br><br>
4. **Controller (비즈니스 로직 호출)**
   - HandlerAdapter가 Controller를 호출
   - Controller는 Service 계층을 호출해서 비즈니스 로직을 수행하고, 그 결과 데이터를 Model에 담음
   - 처리 후 View 이름(view name)을 반환 (`return "userList";`)
     <br><br>
5. **ViewResolver (뷰 이름 -> 실제 뷰로 변환)**
   - DispatcherServlet은 반환받은 view name을 ViewResolver에게 넘김.
   - ViewResolver는 `"userList"` → `/WEB-INF/views/userList.jsp` 와 같이 실제 뷰 파일 경로를 찾음.
     <br><br>
6. **View (렌더링 준비)**
   - ViewResolver가 찾은 View 객체를 DispatcherServlet에 반환.
     <br><br>
7. **모델 데이터 전달 및 View 렌더링**
   - DispatcherServlet은 Model 데이터를 View로 전달.
   - View(JSP, Thymeleaf 등)가 모델 데이터를 이용해 HTML을 생성.
     <br><br>
8. **클라이언트에게 Response 반환**
   - 완성된 View(HTML)가 클라이언트(브라우저)로 응답됨.
     <br><br>
***

### 오늘 강의시간, 회고시간에 대한 느낀점
오늘은 Spring MVC의 전체 요청 처리 흐름을 단계별로 따라가며 구조를 이해했다.  
기존에는 @Controller나 @Service를 단순히 “그냥 붙이는 것” 정도로 생각했는데,  
오늘 그림을 통해 DispatcherServlet이 요청을 받아 내부적으로 어떤 과정을 거치는지를 명확히 알 수 있었다.  

회고 시간에는 “MVC가 왜 필요한가?”를 다시 돌아보게 되었다.  
단순히 코드 구조를 나누기 위한 게 아니라,  
유지보수성과 역할 분리를 극대화하기 위한 설계 철학이라는 걸 체감했다.  
앞으로 코드를 짤 때 단순히 동작만 맞추는 게 아니라,  
흐름의 의도를 이해하고 구조적으로 짜야겠다는 생각이 들었다.  