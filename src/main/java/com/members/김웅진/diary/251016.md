### 오늘 배운 내용 중 가장 기억에 남는 것

주로 반복적으로 언급된 핵심 키워드는 웹 애플리케이션 개발의 기본 구조와 Spring MVC 프레임워크의 동작 원리를 나타내는 부분들에 대해서 수업을 들었다.

특히 쿠키 부분에 대한 것이 기억에 남았는데 쿠키라는것이 개발과정을 정식으로 배우기 전의 제 상식선에서는 쿠키를 그냥 삭제하는 것 정도로만 알고 있었는데,

1. [ ] **쿠키 삭제 방법**: _쿠키는 프로그램 내에서 직접 삭제할 수 없으므로, 똑같은 이름의 쿠키를 새로 만든 다음 유지 시간(setMaxAge)을 0으로 설정하여 브라우저에서 사라지게 하는 방법을 사용해야 합니다_

# 레이어드 아키텍처 및 역할 분리

애플리케이션의 유지보수성과 확장성을 높이기 위한 설계 패턴으로, 관심사 분리가 핵심입니다.
* • 목적: **관심사의 분리(Separation of Concerns)**를 통해 유지보수성, 확장성, 테스트 용이성을 향상시키는 것이 목적입니다.
* • 주요 3계층:
* ◦ 프레젠테이션 계층 (Controller): HTTP 요청/응답 처리와 라우팅을 담당합니다.
* ◦ 비즈니스 로직 계층 (Service): 애플리케이션의 핵심 기능과 비즈니스 규칙을 처리하며, 트랜잭션 관리를 담당합니다.
* ◦ 데이터 접근 계층 (Repository): 데이터베이스에 대한 CRUD 작업을 수행합니다.
* • 통신 원칙: 각 계층은 오직 인접한 계층과만 통신해야 하며, 상위 계층은 하위 계층에 의존하지만 역방향은 불가하다는 중요한 원칙이 있습니다.
* • Controller의 책임: Controller는 비즈니스 로직을 Service에 위임하고, 유효성 검증이나 데이터 모델에 데이터 추가 등의 역할만 수행해야 합니다.
* • Service의 책임: Service 계층은 비즈니스 로직을 효과적으로 캡슐화하고, 컨트롤러가 직접 데이터를 처리하지 않도록 합니다.


![이미지에 대한 설명](https://carami.github.io/likelion-backend-guide/spring/images/2024-05-11-13-31-31.png)
### 오늘 배운 내용 중 어려웠던 것

가장 어려웠던 부분은 웹 애플리케이션의 요청 흐름 제어와 관련된 개념이었습니다.
1. **Forward와 Redirect의 명확한 차이**: Forward는 서버 내부에서 요청이 한 번만 발생하는 반면, Redirect는 클라이언트가 새로운 요청을 다시 보내는 2회 요청 방식이며 URL이 변경된다는 차이가 혼동스러웠습니다. 특히 POST 요청 처리 후 중복 제출을 막기 위해 Redirect를 사용해야 한다는 **PRG 패턴(Post-Redirect-Get)**의 필요성을 완전히 이해하고 실제 코드에 적용하는 부분이 어려웠습니다.
2.7.1 Forward vs Redirect
   2. 
        | 구분 |	Forward | Redirect |
        |----|------------|---------|
        | URL 변경	| 변경 안 됨	| 변경됨 |
        | 요청 횟수	| 1회	| 2회 |
        | 데이터 전달	| Request 속성 사용	| Flash 속성 사용 |
        | 용도	| 서버 내부 페이지 이동	| PRG 패턴, 외부 URL |****

2. **스코프(Scope)와 상태 관리**: HTTP 프로토콜이 기본적으로 비상태성(Stateless)을 갖기 때문에, Request 스코프와 Session 스코프를 명확히 구분하는 것이 중요합니다. 요청이 들어와서 응답이 나갈 때 사라지는 Request 객체에 데이터를 맡기기 위해 Model 객체를 사용한다는 점, 그리고 리다이렉트 시 Request 스코프가 사라지므로 데이터가 유실된다는 개념을 이해하는 데 시간이 필요했습니다.
3. **모델 어트리뷰트와 규칙**: @ModelAttribute나 @RequestParam처럼 스프링 프레임워크가 "자동으로" 값을 채워주는 기능들이 사실은 개발자가 정해진 **규칙(예: 폼 필드 이름과 객체 필드 이름 일치)**을 지켰기 때문에 가능한 것이며, 이 규칙을 위반했을 때 발생하는 오류를 파악하는 것이 어려움을 느꼈습니다

### 오늘 강의시간, 회고시간에 대한 느낀점

시간이 예상보다 훨씬 빨리 가는 것 같아 진도를 더 나가야 한다는 압박감이 있었지만, 복잡한 개념도 화면에 나오는 동작을 직접 보면서 학습하니 재미있었습니다.
강사님께서 스프링 프레임워크가 어노테이션과 리플렉션 기술을 이용해 상속 없이도 상속받은 것처럼 동작하게 만든다는 설계 원칙을 강조해주신 덕분에, 단순히 기능을 외우는 것이 아니라 프레임워크의 내부적인 흐름과 설계 의도를 이해하려고 노력해야겠다는 생각을 했습니다. 복잡한 밸리데이션 처리나 요청 처리 흐름을 직접 구현했을 때의 어려움과 비교하며 스프링이 제공하는 기능이 얼마나 강력하고 "간편해진" 것인지 느낄 수 있었습니다. 앞으로도 단순히 코드를 작성하는 것을 넘어 프레임워크가 정한 약속을 정확히 지키는 것이 중요함을 명심해야겠습니다.