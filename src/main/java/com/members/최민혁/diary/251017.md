### 오늘 배운 내용 중 가장 기억에 남는 것

### 상태 정보 유지 기술 < 쿠키, 세션>
- 쿠키와 세션은 항상 같이 존재한다.
- 쿠키 - 클라이언트가 저장 (노출위험성이 높다)
- 세션 - 서버가 저장
- 쿠키와 세션은 서로 연결되어 있다.(약간 FK 같은 느낌..)
  - 세션이 들고 있는 데이터가 어떤 클라이언트의 데이턴지 알아야하기 때문..?

### HttpServletResponse // HttpServletRequest
- HttpServletResponse 
  - 서블릿 응답 -> 서버가 클라이언트로 보낼 응답 정보를 담은 객체
  - write
- HttpServletRequest
  - 서블릿 요청 -> 클라이언트로부터 넘어온 요청 정보를 담은 객체
  - read




### IoC / DI 가 정확히 어떤 역할인가
- IoC 
  - 객체 생성을 해줌
  - 프로그램의 흐름 제어를 개발자가 아닌 프레임워크가 맡는 것
- DI
  - 객체를 매개변수에 넣는 등 주입하여 사용하게 하는 것..?
  - 필요한 객체를 외부에서 주입하는 방식

### Session
- Scope 개념의 session과 상태정보 개념의 session은 같은 객체이다.
  - 단 두 개념의 쓰임새가 다름.
  - (Scope) 스프링이나 JSP에서 Bean이나 데이터가 머무는 범위를 구분할 때 사용하는 이름
  - (상태정보) 데이터 저장소
- HttpSession <String, Object>
  - Key는 String, Value는 Object 타입으로 받는 Map과 같은 형태
  - Session의 value에는 보통 user타입이 들어가기 때문에 String 보다는 Object를 매개변수 타입으로 쓰는게 좋다.
- session은 하나의 객체로만 사용되고 새로운 session 요청이 들어오면 덮어씌운다.

### @SessionAttribute(name="admin", required = false) Object admin)

- required란?
  - Value의 값이 ture인지 false인지를 보는 것
- required = true ;
  - admin의 값이 null 일때 오류발생
- required = false ;
  - admin 값이 null 일 때 오류발생이 아닌 null을 return




### SessionAttribute("name")
- name 객체를 바인딩해줌.



### Request Scope와 Session Scope의 차이
- Request Scope
```
@SessionAttributes("name")
@GetMapping("/visit")
public String visit(@RequestParam(name="visitCount", defaultValue = "0")int visitCount, 
Model model) {
visitCount++;
model.addAttribute("visitCount", visitCount); //sessionScope에 저장됨..
return "visit";
}

```
visitCount 증가 XXX  
- Session Scope
```angular2html
@SessionAttributes("name")
@ModelAttribute("visitCount")
    public int initVisitCount() {
        System.out.println("initVisitCount");
        return 0;
    }

    @GetMapping("/visit")
    public String visit(@ModelAttribute("visitCount") int visitCount, Model model) {
        visitCount++;
        model.addAttribute("visitCount", visitCount); //sessionScope에 저장됨..
        return "visit";
    }
```
visitCount 증가OOO
새로고침으로는 세션이 중지되지 않음, 요청은 계속들어감


### @SessionAttribute("name") //@SessionAttributes("name")
- @SessionAttribute("name")
  - 세션에 있는 값을 꺼내올 때 사용
  - 보통 매개변수에 서 사용된다
  - ``public String myPage(@SessionAttribute("loginUser") User user)``
- @SessionAttributes("name")
  - 세션에 값을 자동으로 저장
  - @Controller 위에 위치함
  - `` public String visit(@ModelAttribute("visitCount") int visitCount, Model model)``
  - 모델에 visitCount 값이 들어가면 자동으로 세션에도 저장된다.


### @ModelAttribute("visit") 
- visit을 키로 가진 객체가 없을 때만 메서드 실행



### Return forward:/destination && redirect:/destination



- 강사님의 리다이렉트 예문에서 null이 뜬 이유는 각 로직들이 request scope라서.  
  
이런 로그인 같은 경우는 session객체에 넣어줘서 redirect가 되어도 유지될 수 있게 해주어야한다.
```angular2html

@PostMapping("/login")
public String login(@RequestParam String username,
@RequestParam String password,
HttpSession session) {
// 1. 로그인 검증
User user = userService.login(username, password);

    if (user != null) {
        // 2. 로그인 성공 시 사용자 정보 세션에 저장
        session.setAttribute("loginUser", user); ///여기!

        // 3. 홈으로 리다이렉트
        return "redirect:/home";
    } else {
        return "redirect:/login?error=true";
    }
}
```





### @ControllerAdvice /page
#### 1. 모든 컨트롤러엑서 나오는 예외를 처리할 수 있음
  
```angular2html
 @ControllerAdvice
   public class GlobalExceptionHandler {

   @ExceptionHandler(NullPointerException.class)
   public String handleNullPointer(Exception ex, Model model) {
   model.addAttribute("error", "널포인터 예외 발생!");
   return "errorPage";
   }
   }
```
Exception.class에 정의된 오류가 value로 들어오면 mapping
#### 2. 모든 컨트롤러에 바인딩되는 공통모델 만들 수 있음

```angular2html
 @ControllerAdvice
   public class GlobalModelAttribute {

   @ModelAttribute("appName")
   public String appName() {
   return "나의 웹앱";
   }
   }
   

```
모든 컨트롤러에서 ${appName}이라는 속성을 사용할 수 있음.  
위에 기술한 visit 예문처럼..  
----spring data jdbc---
``` resource ->yml파일
spring:
application:
name: springjdvc


datatource:
url: jdbc:mysql://localhost:3306/
username : spring
password : spring1234
driver-class-name : com.mysql.cj.jdbc.Driver
```

줄맞춤이 중요해!!  
오타가 나면 오류남


### 커넥션 풀(Connection Pool)
- 데이터베이스랑 통신하려면 매번 새로 연결을 만들면 속도가 느리고 비용이 큼
그래서 미리 일정 수의 연결(Connection)을 만들어두고,
재사용하는 방식


### Spring JDBC
- 다이어그램
  - user <-> jdbcTemplate <-> jdbcDriver <-> Database
- spring jdbc 는 jdbcTemplate을 제공해준 것
- jdbcTemplate객체의 update메서드
  - update -- del,insert,update 쿼리문을 다 사용가능

Spring data JDBC
@Table("user")
@ID --> PK
CrudRepository --> crud를 구현해 놓은 인터페이스



### 오늘 배운 내용 중 어려웠던 것



### 오늘 강의시간, 회고시간에 대한 느낀점