### 오늘 배운 내용 중 가장 기억에 남는 것

로깅 구조에 대해 배운 점이 기억에 남는다.
로깅이란 애플리케이션의 실행 중 발생하는 이벤트나 상태 정보를 기록하는 것이다.

```java
import org.slf4j.MDC;
import javax.servlet.FilterChain;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;
import java.util.UUID;

public class MDCFilter extends OncePerRequestFilter {
@Override
protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
throws ServletException, IOException {
String requestId = req.getHeader("5-Request-Id");
if (requestId == null) requestId = UUID.randomUUID().toString();

        try {
            MDC.put("requestId", requestId);
            chain.doFilter(req, res);
        } finally {
            MDC.clear(); 
        }
    }
```
로깅의 목적으로는 총 6가지가 있다.

1. 디버깅: 개발 중 발생하는 문제 해결
2. 모니터링: 운영 중 시스템 상태 추적
3. 감사(Audit): 보안 및 규정 준수를 위한 기록
4. 성능 분석: 병목 구간 및 성능 문제 파악
5. 비즈니스 분석: 사용자 행동 패턴 분석

이러한 로깅 프레임워크와  기존에 시스템 콘솔에 단순히 출력하기만 하던 print와 비교한 차이점은 다음과 같다.

| 구분 | `System.out.println()` | **로깅 프레임워크**                                |
|:------:|:--------------------|:--------------------------------------------|
| **성능** | 동기 처리로 느림 | 비동기 처리 가능 — 성능 저하 최소화                       |
| **레벨 제어** | 제어 불가능 | 로그 레벨별 출력 제어 가능 (`INFO`, `WARN`, `ERROR` 등) |
| **출력 대상** | 콘솔만 가능 | 콘솔, 파일, DB, 네트워크 등 다양한 대상에 출력 가능            |
| **포맷팅** | 수동 처리 필요 | 자동 포맷팅 및 시간·스레드 정보 포함 가능                    |
| **운영 중 변경** | 코드 수정 및 재배포 필요 | 설정 파일(`logback.xml` 등)만 수정하면 즉시 반영 가능       |

- System.out.println()은 간단하지만 한계가 명확하며, 
- 로깅 프레임워크(Logback, Log4j, SLF4J)를 사용하면 더 안전하고 효율적이며 운영 환경에서도 쉽게 관리할 수 있다.
- 로깅 라이브러리의 계층 구조는 코드 → SLF4J API → Logback → Output으로 구성된다. 
- 코드에서 작성한 로그는 SLF4J를 통해 Logback으로 전달되며, Logback이 로그를 처리한 뒤 콘솔이나 파일 등 외부로 출력한다.
- 로깅에는 레벨이 존재하며, 개발자와 일반 사용자에게 적절한 정보를 제공할 수 있다.

비유를 하자면 
- 코드     : TV를 키는 명령문
- SLF4J   : 리모컨 
- Logback : TV 본체
라 할 수 있다.

logger.debug("Processing user: {}", userId); 
의 경우 실제로 로그를 출력하는 것은 Logback이나  SLF4J는 debug의 형태로 로그를 출력하도록 Logback에 전달한다.
그리고 Logback에서는 로깅을 처리한 뒤 출력하는 역할을 담당한다.
마지막으로 Output의 경우 콘솔이나 파일 등 외부에서 직접 볼 수 있도록 하는 출력 장치를 말한다.

로깅에는 레벨이 존재한다. 개발자의 경우 디버그의 과정 중 어디에서 문제가 생겼는지 기록이 남아있어, 추적이 용이하다.
일반 사용자의 경우 'ID: 123이 홈페이지에 접속-접속종료' 등의 흐름을 알 수 있는 정도로 제한한다.
그러한 내용은 아래와 같다.

|     레벨      | 용도 | 사용 예시               |
|:-----------:|:----------------|:--------------------|
|  **TRACE**  | 매우 상세한 디버깅 정보 | 메서드 진입/종료, 변수 값 추적  |
|  **DEBUG**  | 일반적인 디버깅 정보 | 주요 변수 상태, 흐름 제어     |
|  **INFO**   | 일반 정보 | 애플리케이션 시작/종료, 주요 이벤트 |
|  **WARN**   | 경고 메시지 | 잠재적 문제, deprecated API 사용 |
|  **ERROR**  | 오류 메시지 | 예외 발생, 복구 가능한 오류    |

- 일반적으로 `INFO` 레벨은 운영 환경에서 사용된다.
- `DEBUG`는 개발중인 환경에서 보통 활성화 한다.
- `TRACE`는 너무 세밀한 정보를 출력하기 때문에, 디버깅 목적 외에는 잘 사용하지 않는다.


### 오늘 배운 내용 중 어려웠던 것

배운 내용을 완전히 내 것으로 만들지 않은 상태에서 바로 예제를 작성하다 보니 혼동이 오는 경우가 많았다. 
로깅 개념은 이해하기 쉬웠지만, 실제 적용 과정에서 어려움을 느꼈다. 특히 MDC(Mapped Diagnostic Context)가 어려웠다. 
MDC는 Map과 유사한 형태를 가지고 있으나, 로깅 내부에서만 작동한다는 점이 다르다. 
간단히 말하면, 로그에 필요한 컨텍스트(ex. ID, password)를 모든 로그에 자동으로 붙여주는 역할을 한다.
아래는 예제 코드다
```java
import org.slf4j.MDC;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;
import java.util.UUID;

public class MDCFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {
        String requestId = req.getHeader("5-Request-Id");
        if (requestId == null) requestId = UUID.randomUUID().toString();
        try {
            MDC.put("requestId", requestId);
            chain.doFilter(req, res);
        } finally {
            MDC.clear();
        }
    }
}

```


### 오늘 강의시간, 회고시간에 대한 느낀점
오늘 로깅과 MDC를 배우면서, 개념 자체는 이해하기 쉬웠지만 실제 코드에 적용하는 과정에서는 조금 헷갈렸다.
특히 요청마다 고유한 ID를 자동으로 로그에 붙이는 MDC가 Map과 비슷하지만 로깅 내부에서만 작동한다는 점이 새로웠다.
그래도 직접 예제를 구현해보면서 운영 환경에서 로그가 어떻게 활용되는지 감이 잡혔고, 단순한 출력과 체계적인 로깅의 차이를 명확히 느낄 수 있었다.
앞으로 디버깅이나 문제 추적 시 MDC를 적극 활용하면 도움이 될 것 같다.